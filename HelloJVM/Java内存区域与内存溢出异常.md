#Java内存区域与内存溢出异常

##一、运行时数据区域

### 1、程序计数器

（1）占用很小内存

（2）可看成是当前线程执行的字节码的行数指示器

（3）在虚拟机的概念模型中，字节码指示器的工作是靠程序计数器来选取下一位

（4）当执行一条Java方法时，程序计数器记录的是虚拟机字节码指令的地址；
当执行一条Native方法时，程序计数器保留为空

（5）线程私有

（6）是唯一一个虚拟机规范中没有任何OutOfMemeryError的内存区域

### 2、虚拟机栈

（1）线程私有

（2）描述的是Java方法执行的内存模型：每个方法在执行的时候都会创建一个栈针，存储局部变量表、操作数栈、动态链接和方法出口。每个方法从调用到执行完成的过程，就对应着一个栈针从入栈到出栈的过程。

（2）虚拟机规范中约定，当线程请求的栈深度超过虚拟机允许的最大深度会报出StackOverFlowError；当虚拟机栈可以动态扩展时，会因为扩展时内存不足报出OutOfMermaryError。

### 3、本地方法栈

（1）线程私有

（2）调用Native方法时会使用该部分

（3）会报出OutOfMemoryError和StackOverFlowError。

### 4、方法区

（1）线程共享

（2）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

（3）在HotSpot虚拟机中"永久代"就是指方法区，对于其他虚拟机来说，不存在永久代的概念

（4）会发生OOM和stackOverFlowError

### 5、Java堆

（1）线程共享

（2）Java虚拟机所管理的内存中最大的一块

（2）唯一目的：存放对象实例

（3）分成"新生区"和"老年区"，新生代分为Eden，from Servive 和 to Servive三个区域，Eden和Servive比例默认比例8：1

（4）如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError。

### 6、运行时常量池

（1）是方法区的一部分

（2）存放编译期生成的各种字面量和符号引用

（3）具备动态性

（4）当常量池无法再申请内存时，会报OutOfMemoryError。

### 7、直接内存

（1）NIO:避免在Java堆和Native堆中来回复制对象


##二、OOM实战

###1、Java堆内存溢出

###2、虚拟机栈和本地方法栈溢出

###3、方法区和运行时常量池内存溢出

###4、直接内存溢出